#!/usr/bin/env lua
-- 5g-monitor: Real-time TUI monitor for Quectel modems with audio feedback

package.path = "/usr/lib/lua/?.lua;/usr/lib/lua/?/init.lua;" .. package.path

local quectel = require("quectel")
local frequency = quectel.frequency
local thresholds = quectel.thresholds

-- Try to load curses
local curses_ok, curses = pcall(require, "posix.curses")
if not curses_ok then
    io.stderr:write("Error: luaposix curses module required\n")
    io.stderr:write("Install with: opkg install luaposix\n")
    os.exit(1)
end

-- Configuration
local config = quectel.load_config()
local refresh_interval = config.refresh_interval or 5
local beeps_enabled = config.beeps_enabled
if beeps_enabled == nil then beeps_enabled = true end
local running = true

-- Color pairs
local COLOR_NORMAL = 1
local COLOR_EXCELLENT = 2
local COLOR_GOOD = 3
local COLOR_FAIR = 4
local COLOR_POOR = 5
local COLOR_HEADER = 6
local COLOR_5G = 7

local function setup_colors(stdscr)
    if curses.has_colors() then
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(COLOR_NORMAL, curses.COLOR_WHITE, -1)
        curses.init_pair(COLOR_EXCELLENT, curses.COLOR_CYAN, -1)
        curses.init_pair(COLOR_GOOD, curses.COLOR_GREEN, -1)
        curses.init_pair(COLOR_FAIR, curses.COLOR_YELLOW, -1)
        curses.init_pair(COLOR_POOR, curses.COLOR_RED, -1)
        curses.init_pair(COLOR_HEADER, curses.COLOR_BLUE, -1)
        curses.init_pair(COLOR_5G, curses.COLOR_GREEN, -1)
    end
end

local function quality_pair(quality)
    if quality == thresholds.EXCELLENT then return COLOR_EXCELLENT end
    if quality == thresholds.GOOD then return COLOR_GOOD end
    if quality == thresholds.FAIR then return COLOR_FAIR end
    if quality == thresholds.POOR then return COLOR_POOR end
    return COLOR_NORMAL
end

local function beep()
    if beeps_enabled then
        io.write("\a")
        io.flush()
    end
end

local function draw_header(win, status)
    local height, width = win:getmaxyx()

    -- Title bar
    win:attron(curses.A_BOLD)
    win:mvaddstr(0, 0, "5G Monitor")
    win:attroff(curses.A_BOLD)

    -- Device and network info
    local device_str = "?"
    if status.device then
        device_str = string.format("%s %s", status.device.model or "?", status.device.revision or "")
    end

    local network_str = "?"
    if status.operator then
        network_str = string.format("%s (%s)", status.operator.operator or "?", status.operator.mcc_mnc or "?")
    end

    win:mvaddstr(0, 15, string.format("| %s | %s", device_str, network_str))

    -- Status line
    local state = "CONNECTED"
    if status.serving and status.serving.state then
        state = status.serving.state
    end
    local beep_str = beeps_enabled and "BEEP:ON" or "BEEP:OFF"
    local status_str = string.format("| %s | %s", state, beep_str)
    if width > #status_str + 5 then
        win:mvaddstr(0, width - #status_str - 1, status_str)
    end
end

local function draw_serving_cell(win, status, start_row)
    local row = start_row

    if not status.serving then
        win:mvaddstr(row, 0, "No serving cell")
        return row + 1
    end

    local lte = status.serving.lte
    local nr = status.serving.nr5g

    if lte then
        -- LTE header
        win:attron(curses.color_pair(COLOR_HEADER))
        win:attron(curses.A_BOLD)
        win:mvaddstr(row, 0, string.format("[LTE - Band %s]", lte.band or "?"))
        win:attroff(curses.A_BOLD)
        win:attroff(curses.color_pair(COLOR_HEADER))

        local enodeb = quectel.extract_enodeb(lte.cell_id) or "?"
        win:addstr(string.format(" %s | eNodeB: %s | PCI: %s", lte.duplex or "?", enodeb, lte.pci or "?"))
        row = row + 1

        -- Signal values
        local rsrp_q = thresholds.rsrp_quality(lte.rsrp)
        local rsrq_q = thresholds.rsrq_quality(lte.rsrq)
        local sinr_q = thresholds.sinr_quality(lte.sinr)

        win:mvaddstr(row, 2, "RSRP: ")
        win:attron(curses.color_pair(quality_pair(rsrp_q)))
        win:addstr(string.format("%d dBm", lte.rsrp or 0))
        win:attroff(curses.color_pair(quality_pair(rsrp_q)))

        win:addstr(" | RSRQ: ")
        win:attron(curses.color_pair(quality_pair(rsrq_q)))
        win:addstr(string.format("%d dB", lte.rsrq or 0))
        win:attroff(curses.color_pair(quality_pair(rsrq_q)))

        win:addstr(" | SINR: ")
        win:attron(curses.color_pair(quality_pair(sinr_q)))
        win:addstr(string.format("%d dB", lte.sinr or 0))
        win:attroff(curses.color_pair(quality_pair(sinr_q)))

        row = row + 1

        -- Frequency and bandwidth
        local freq_str = frequency.format_frequency(lte.earfcn or 0, false)
        local dl_bw = frequency.format_bandwidth(lte.bandwidth_dl_mhz)
        local ul_bw = frequency.format_bandwidth(lte.bandwidth_ul_mhz)
        win:mvaddstr(row, 2, string.format("Freq: %s | BW: DL %s / UL %s", freq_str, dl_bw, ul_bw))
        row = row + 1
    end

    if nr then
        row = row + 1

        -- 5G header
        win:attron(curses.color_pair(COLOR_5G))
        win:attron(curses.A_BOLD)
        win:mvaddstr(row, 0, string.format("[5G-NSA - Band n%s]", nr.band or "?"))
        win:attroff(curses.A_BOLD)
        win:attroff(curses.color_pair(COLOR_5G))
        win:addstr(string.format(" PCI: %s", nr.pci or "?"))
        row = row + 1

        -- Signal values
        local rsrp_q = thresholds.rsrp_quality(nr.rsrp)
        local rsrq_q = thresholds.rsrq_quality(nr.rsrq)
        local sinr_q = thresholds.sinr_quality(nr.sinr)

        win:mvaddstr(row, 2, "RSRP: ")
        win:attron(curses.color_pair(quality_pair(rsrp_q)))
        win:addstr(string.format("%d dBm", nr.rsrp or 0))
        win:attroff(curses.color_pair(quality_pair(rsrp_q)))

        win:addstr(" | RSRQ: ")
        win:attron(curses.color_pair(quality_pair(rsrq_q)))
        win:addstr(string.format("%d dB", nr.rsrq or 0))
        win:attroff(curses.color_pair(quality_pair(rsrq_q)))

        win:addstr(" | SINR: ")
        win:attron(curses.color_pair(quality_pair(sinr_q)))
        win:addstr(string.format("%.1f dB", nr.sinr or 0))
        win:attroff(curses.color_pair(quality_pair(sinr_q)))

        row = row + 1

        -- Frequency and bandwidth
        local freq_str = frequency.format_frequency(nr.arfcn or 0, true)
        local bw = frequency.format_bandwidth(nr.bandwidth_mhz)
        win:mvaddstr(row, 2, string.format("Freq: %s | BW: %s", freq_str, bw))
        row = row + 1
    end

    return row
end

local function draw_carrier_aggregation(win, status, start_row)
    local row = start_row + 1

    if not status.ca or (not status.ca.pcc and #status.ca.scc == 0) then
        win:mvaddstr(row, 0, "Carrier Aggregation: none")
        return row + 1
    end

    win:attron(curses.A_BOLD)
    win:mvaddstr(row, 0, "Carrier Aggregation:")
    win:attroff(curses.A_BOLD)
    row = row + 1

    local function draw_carrier(carrier)
        local is_nr = carrier.rat == "nr"
        local band_name = quectel.format_band(carrier.band, is_nr)
        local rsrp_q = thresholds.rsrp_quality(carrier.rsrp)

        local role_col = carrier.role == "pcc" and COLOR_HEADER or COLOR_EXCELLENT
        win:attron(curses.color_pair(role_col))
        win:mvaddstr(row, 2, string.format("%-3s", carrier.role:upper()))
        win:attroff(curses.color_pair(role_col))

        win:addstr(string.format(" %-8s | PCI %3s | RSRP ", band_name, carrier.pci or "-"))

        win:attron(curses.color_pair(quality_pair(rsrp_q)))
        win:addstr(string.format("%4s", carrier.rsrp or "-"))
        win:attroff(curses.color_pair(quality_pair(rsrp_q)))

        win:addstr(string.format(" | SINR %4s", carrier.sinr or "-"))

        row = row + 1
    end

    if status.ca.pcc then
        draw_carrier(status.ca.pcc)
    end

    for _, scc in ipairs(status.ca.scc) do
        draw_carrier(scc)
    end

    return row
end

local function draw_neighbours(win, status, start_row, max_rows)
    local row = start_row + 1

    if not status.neighbours or #status.neighbours == 0 then
        win:mvaddstr(row, 0, "Neighbour Cells: none")
        return row + 1
    end

    win:attron(curses.A_BOLD)
    win:mvaddstr(row, 0, "Neighbour Cells:")
    win:attroff(curses.A_BOLD)
    row = row + 1

    local count = 0
    for _, nb in ipairs(status.neighbours) do
        if count >= max_rows then
            win:mvaddstr(row, 2, string.format("... and %d more", #status.neighbours - count))
            break
        end

        local rsrp_q = thresholds.rsrp_quality(nb.rsrp)
        local freq_str = frequency.format_frequency(nb.earfcn or 0, false)

        win:mvaddstr(row, 2, string.format("%-3s %-18s | PCI %3s | RSRP ",
            nb.rat:upper(), freq_str, nb.pci or "-"))

        win:attron(curses.color_pair(quality_pair(rsrp_q)))
        win:addstr(string.format("%4s", nb.rsrp or "-"))
        win:attroff(curses.color_pair(quality_pair(rsrp_q)))

        win:addstr(string.format(" | (%s)", nb.scope or "?"))

        row = row + 1
        count = count + 1
    end

    return row
end

local function draw_help(win)
    local height, width = win:getmaxyx()
    win:mvaddstr(height - 1, 0, "q:quit  r:refresh  b:toggle beep  j/k:scroll")
end

local function main_loop(stdscr, modem)
    local last_beep_time = 0

    while running do
        -- Get modem status
        local ok, status = pcall(function() return modem:get_status() end)
        if not ok then
            status = {}
        end

        -- Clear and redraw
        stdscr:clear()

        draw_header(stdscr, status)
        local row = draw_serving_cell(stdscr, status, 2)
        row = draw_carrier_aggregation(stdscr, status, row)

        local height = stdscr:getmaxyx()
        local max_neighbours = height - row - 3
        if max_neighbours > 0 then
            draw_neighbours(stdscr, status, row, max_neighbours)
        end

        draw_help(stdscr)

        stdscr:refresh()

        -- Audio feedback based on SINR
        local sinr = nil
        if status.serving then
            if status.serving.nr5g and status.serving.nr5g.sinr then
                sinr = status.serving.nr5g.sinr
            elseif status.serving.lte and status.serving.lte.sinr then
                sinr = status.serving.lte.sinr
            end
        end

        if sinr and beeps_enabled then
            local interval = thresholds.beep_interval(sinr)
            if interval then
                local now = os.clock()
                if now - last_beep_time >= interval then
                    beep()
                    last_beep_time = now
                end
            end
        end

        -- Handle input with timeout
        stdscr:timeout(refresh_interval * 1000)
        local ch = stdscr:getch()

        if ch then
            if ch == string.byte('q') or ch == string.byte('Q') then
                running = false
            elseif ch == string.byte('r') or ch == string.byte('R') then
                -- Force refresh (loop continues)
            elseif ch == string.byte('b') or ch == string.byte('B') then
                beeps_enabled = not beeps_enabled
            end
        end
    end
end

local function print_usage()
    print("Usage: 5g-monitor [OPTIONS]")
    print("")
    print("Options:")
    print("  --interval N  Refresh interval in seconds (default: 5)")
    print("  --no-beep     Disable audio feedback")
    print("  --help        Show this help")
end

-- Parse arguments
local i = 1
while i <= #arg do
    local a = arg[i]
    if a == "--interval" then
        i = i + 1
        refresh_interval = tonumber(arg[i]) or 5
    elseif a == "--no-beep" then
        beeps_enabled = false
    elseif a == "--help" or a == "-h" then
        print_usage()
        os.exit(0)
    end
    i = i + 1
end

-- Initialize curses
local stdscr = curses.initscr()
curses.cbreak()
curses.echo(false)
curses.nl(false)
stdscr:keypad(true)
curses.curs_set(0)  -- Hide cursor

setup_colors(stdscr)

-- Connect to modem
local modem = quectel.create_modem()

-- Run main loop with cleanup on exit
local ok, err = pcall(function()
    main_loop(stdscr, modem)
end)

-- Cleanup
curses.endwin()
modem:close()

if not ok then
    io.stderr:write("Error: " .. tostring(err) .. "\n")
    os.exit(1)
end
