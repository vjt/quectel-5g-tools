#!/usr/bin/env lua
-- 5g-monitor: Real-time TUI monitor for Quectel modems with audio feedback
-- Uses simple ANSI escape codes instead of curses for portability

package.path = "/usr/lib/lua/?.lua;/usr/lib/lua/?/init.lua;" .. package.path

local quectel = require("quectel")
local display = quectel.display
local thresholds = quectel.thresholds

-- Try to load posix modules
local posix_time = nil
local posix_signal = nil
pcall(function() posix_time = require("posix.time") end)
pcall(function() posix_signal = require("posix.signal") end)

-- Configuration
local config = quectel.load_config()
local refresh_interval = config.refresh_interval or 5
local beeps_enabled = config.beeps_enabled
if beeps_enabled == nil then beeps_enabled = true end

-- State
local running = true
local modem = nil

-- Interruptible sleep using posix.time.nanosleep
local function sleep(seconds)
    if posix_time and posix_time.nanosleep then
        local sec = math.floor(seconds)
        local nsec = math.floor((seconds - sec) * 1e9)
        posix_time.nanosleep({tv_sec = sec, tv_nsec = nsec})
    else
        -- Fallback to os.execute, but check running flag frequently
        local remaining = seconds
        while remaining > 0 and running do
            local chunk = math.min(remaining, 0.5)
            os.execute("sleep " .. chunk)
            remaining = remaining - chunk
        end
    end
end

-- Signal handling for Ctrl+C
local function setup_signal_handler()
    if posix_signal and posix_signal.signal then
        posix_signal.signal(posix_signal.SIGINT, function()
            running = false
        end)
        posix_signal.signal(posix_signal.SIGTERM, function()
            running = false
        end)
        return true
    end
    return false
end

local function cleanup()
    -- Show cursor and reset terminal
    io.write(display.SHOW_CURSOR)
    io.write(display.Colors.RESET)
    io.flush()
    if modem then
        modem:close()
    end
end

local function draw_header(status)
    local device_str = "?"
    if status.device then
        device_str = string.format("%s %s", status.device.model or "?", status.device.revision or "")
    end

    local network_str = "?"
    if status.operator then
        network_str = string.format("%s (%s)", status.operator.operator or "?", status.operator.mcc_mnc or "?")
    end

    local state = "CONNECTED"
    if status.serving and status.serving.state then
        state = status.serving.state
    end
    local beep_str = beeps_enabled and "BEEP:ON" or "BEEP:OFF"

    print(string.format("%s5G Monitor%s | %s | %s | %s | %s",
        display.color(display.Colors.BOLD), display.color(display.Colors.RESET),
        device_str, network_str, state, beep_str))
    print(string.rep("-", 78))
end

local function draw_footer()
    print("")
    print("Press Ctrl+C to quit")
end

local function do_beeps(sinr)
    if not beeps_enabled or not sinr then return end

    local num_beeps = thresholds.beep_count(sinr)
    if num_beeps and num_beeps > 0 then
        display.beep(num_beeps, 0.7)
    end
end

local function main_loop()
    while running do
        -- Get modem status
        local ok, status = pcall(function() return modem:get_status() end)
        if not ok then
            status = {}
        end

        -- Clear screen and move cursor home, hide cursor
        io.write(display.CLEAR .. display.HOME .. display.HIDE_CURSOR)

        draw_header(status)
        display.print_serving_cell(status, true)
        display.print_carrier_aggregation(status, true)
        display.print_neighbours(status, 5)
        draw_footer()

        io.flush()

        -- Audio feedback based on SINR
        local sinr = display.get_sinr(status)
        do_beeps(sinr)

        -- Check if we should exit before sleeping
        if not running then break end

        -- Sleep for refresh interval (interruptible)
        sleep(refresh_interval)
    end
end

local function print_usage()
    print("Usage: 5g-monitor [OPTIONS]")
    print("")
    print("Options:")
    print("  --interval N  Refresh interval in seconds (default: 5)")
    print("  --no-beep     Disable audio feedback")
    print("  --help        Show this help")
end

-- Parse arguments
local i = 1
while i <= #arg do
    local a = arg[i]
    if a == "--interval" then
        i = i + 1
        refresh_interval = tonumber(arg[i]) or 5
    elseif a == "--no-beep" then
        beeps_enabled = false
    elseif a == "--help" or a == "-h" then
        print_usage()
        os.exit(0)
    end
    i = i + 1
end

-- Setup signal handling
local has_signals = setup_signal_handler()

-- Connect to modem
modem = quectel.create_modem()

if has_signals then
    print("Starting 5G Monitor... (Ctrl+C to quit)")
else
    print("Starting 5G Monitor... (Ctrl+C to quit, signal handling not available)")
end

-- Run main loop with error handling
local ok, err = pcall(main_loop)

-- Cleanup
cleanup()

if not ok and running then
    -- Only print error if we didn't exit due to signal
    io.stderr:write("Error: " .. tostring(err) .. "\n")
    os.exit(1)
end
